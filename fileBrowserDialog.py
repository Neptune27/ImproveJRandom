import datetime
import os
import pathlib
import traceback

import docx
import docx2txt
from PySide6.QtCore import *  # type: ignore
from PySide6.QtGui import *  # type: ignore
from PySide6.QtWidgets import *  # type: ignore
from docx.shared import Pt

import SQLController
import docxExportDialog
from classType import JapanWords

NOW_DATE_TIME = datetime.datetime
NOW_DATE = datetime.date.today()


def initWarningBox(text, title):
    warning = QMessageBox()
    warning.setText(text)
    warning.setWindowTitle(title)
    warning.setStandardButtons(QMessageBox.Ok)
    warning.exec()

class SaveDialog(QFileDialog):
    def __init__(self, texts, heading=None):
        super().__init__()
        self.heading = heading
        self.texts = texts

        if heading is None:
            self.heading = ''
        self.save_location, _ = self.getSaveFileName(self, "Save", "", "Text file (*.txt) ;;Word Document (*.docx)")
        try:
            if self.save_location.endswith(".txt"):
                with open(self.save_location, "w", encoding='UTF-8') as save:
                    save.write(texts)
            elif self.save_location.endswith(".docx"):
                # self.initDocxOptions()
                self.saveDocx()
            else:
                initWarningBox('Please select correct file!', 'Warning')
        except FileNotFoundError:
            print("[WARNING] File not found: " + self.save_location)
        except PermissionError:
            initWarningBox(f'Permission denied. Please close any app associated \nwith this file and try again.',
                           'Error')

    def saveDocx(self):
        self.initDocxOptions()

        if self.docxOption.isAccepted:
            wordObjList = SQLController.getWordsObjects(self.texts)
            # print(save_location)
            self.document = docx.Document()
            docHeading = self.document.add_heading()
            run = docHeading.add_run(f'{self.heading}')
            font = run.font
            font.size = Pt(35)
            for wordObj in wordObjList:
                self.JPObjectToText(wordObj)

            self.document.core_properties.comments = 'generated by Kanji Browser'
            self.document.core_properties.author = 'Kanji Browser by Minh Tr√≠'
            self.document.save(f'{self.save_location}')

    def initDocxOptions(self):
        try:
            self.docxOptionDialog = QDialog()
            # self.docxOptionDialog.setAttribute(Qt.WA_DeleteOnClose)
            self.docxOption = docxExportDialog.Ui_DocxSelector()
            self.docxOption.setupUi(self.docxOptionDialog)
            self.docxOptionDialog.exec()
        except Exception:
            traceback.print_exc()

    def JPObjectToText(self, obj: JapanWords):
        text = ''
        self.index = 0
        self.paragraphRun = self.document.add_paragraph()
        if self.docxOption.kanjiBox.isChecked() and self.docxOption.meansBox.isChecked():
            self.checkFirst(f'{obj.kanji} - {obj.mean}', self.index)
        else:
            if self.docxOption.kanjiBox.isChecked():
                self.checkFirst(f'{obj.kanji}\n', self.index)
            if self.docxOption.meansBox.isChecked():
                self.checkFirst(f'{obj.mean}\n', self.index)
        if self.docxOption.englishBox.isChecked():
            self.checkFirst(f'{obj.english}\n', self.index)
        if self.docxOption.vietnameseBox.isChecked():
            self.checkFirst(f'{obj.vietnamese}\n', self.index)
        if self.docxOption.OnBox.isChecked():
            self.checkFirst(f'On: {obj.on}'.replace(' ', ', ') + f'\n', self.index)
        if self.docxOption.kunBox.isChecked():
            self.checkFirst(f'Kun: {obj.kun}'.replace(' ', ', ') + f'\n', self.index)
        if self.docxOption.strokesBox.isChecked():
            self.checkFirst(f'{obj.strokes}\n', self.index)
        if self.docxOption.radicalsBox.isChecked():
            self.checkFirst(f'{obj.radicals}'.replace('\n', ' ') + f'\n', self.index)
        if self.docxOption.partsBox.isChecked():
            self.checkFirst(f'{obj.parts}'.replace('\n', ' ') + f'\n', self.index)
        if self.docxOption.taughtBox.isChecked():
            self.checkFirst(f'{obj.taught}\n', self.index)

    def checkFirst(self, text, index):
        if index == 0:
            heading = self.document.add_heading(level=2)
            run = heading.add_run(f'{text}:')
            font = run.font
            font.size = Pt(20)
            self.paragraphRun = self.document.add_paragraph()
        else:
            self.paragraphRun.add_run(f'- {text}')
        self.index += 1

    # def addThingToDocx(self, document, attribute, ):
    #     pass


class AutoSave:
    def __init__(self, location):
        self.text = ''
        self.location = location

    def save(self):
        self.dirLoc = f"{self.location}{NOW_DATE}\\"
        if not os.path.exists(self.dirLoc):
            try:
                os.mkdir(self.dirLoc)
            except OSError as ex:
                initWarningBox("Unable to create directory at" + self.dirLoc, 'ERROR')
        nowLoc = str(NOW_DATE_TIME.now())[:-7].replace(':', ' ')
        writeLoc = f"{self.dirLoc}{nowLoc}.txt"
        with open(writeLoc, 'w', encoding='UTF-8') as loc:
            loc.write(self.text)



class FileReader(QFileDialog):

    def __str__(self):
        return self.text

    def __init__(self):
        super().__init__()
        self.text = ''

    def resetText(self):
        self.text = ''

    def getFileTexts(self):
        self.fileLocations, _ = self.getOpenFileNames(self, "Save", "", "Text file (*.txt *.docx)", )
        for fileLoc in self.fileLocations:
            self.processText(fileLoc)

    def processText(self, fileLoc):
        if fileLoc.endswith('.docx'):
            self.docxToText(fileLoc)
        elif fileLoc.endswith('.txt'):
            self.txtToText(fileLoc)
        else:
            print('[WARNING] File not found')

    def getFolderTexts(self):
        self.fileLocations = self.getExistingDirectory(self, 'Select Directory', '')
        print(self.fileLocations)
        path = pathlib.Path(self.fileLocations)
        fileMatch = path.glob('*.txt')
        for file in fileMatch:
            self.processText(str(file))
        fileMatch = path.glob('*.docx')
        for file in fileMatch:
            self.processText(str(file))
            # print(file)
        # print(self.text)
        # print(fileMatch)
        # print(self.fileLocations)

    def txtToText(self, fileLoc):
        with open(fileLoc, 'r', encoding='UTF-8') as file:
            self.text += file.read()
            self.text += '\n'

    def docxToText(self, fileLoc):
        text = docx2txt.process(fileLoc)
        self.text += text

    def getFileLocations(self):
        if type(self.fileLocations) is list:
            return ', '.join(self.fileLocations)
        else:
            return self.fileLocations


class DatabaseLocation(QFileDialog):
    def __str__(self):
        return self.databaseLocation

    def __init__(self, database):
        super().__init__()
        self.databaseLocation, _ = self.getOpenFileName(self, "Save", "", "SQLite File (*.db)", )
        if self.databaseLocation == '':
            self.databaseLocation = database
